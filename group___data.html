<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>University of Nottingham JamSail Misson: Data handling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">University of Nottingham JamSail Misson
   </div>
   <div id="projectbrief">CubeSat Solution</div>
  </td>
 </tr>
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group___data.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Data handling</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaac2cfdd8e8d7b927220196d9f65743fe" id="r_gaac2cfdd8e8d7b927220196d9f65743fe"><td class="memItemLeft" align="right" valign="top">SP_API enum sp_return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaac2cfdd8e8d7b927220196d9f65743fe">sp_blocking_read</a> (struct <a class="el" href="structsp__port.html">sp_port</a> *port, void *buf, size_t count, unsigned int timeout_ms)</td></tr>
<tr class="separator:gaac2cfdd8e8d7b927220196d9f65743fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddc42d25c8bcfb5a3eae54fd0af4144e" id="r_gaddc42d25c8bcfb5a3eae54fd0af4144e"><td class="memItemLeft" align="right" valign="top">SP_API enum sp_return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaddc42d25c8bcfb5a3eae54fd0af4144e">sp_blocking_read_next</a> (struct <a class="el" href="structsp__port.html">sp_port</a> *port, void *buf, size_t count, unsigned int timeout_ms)</td></tr>
<tr class="separator:gaddc42d25c8bcfb5a3eae54fd0af4144e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab00baf6fc9d695814bd6b1f3489bf8a4" id="r_gab00baf6fc9d695814bd6b1f3489bf8a4"><td class="memItemLeft" align="right" valign="top">SP_API enum sp_return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab00baf6fc9d695814bd6b1f3489bf8a4">sp_nonblocking_read</a> (struct <a class="el" href="structsp__port.html">sp_port</a> *port, void *buf, size_t count)</td></tr>
<tr class="separator:gab00baf6fc9d695814bd6b1f3489bf8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1457d61301828d8cc18b6f93dca06406" id="r_ga1457d61301828d8cc18b6f93dca06406"><td class="memItemLeft" align="right" valign="top">SP_API enum sp_return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1457d61301828d8cc18b6f93dca06406">sp_blocking_write</a> (struct <a class="el" href="structsp__port.html">sp_port</a> *port, const void *buf, size_t count, unsigned int timeout_ms)</td></tr>
<tr class="separator:ga1457d61301828d8cc18b6f93dca06406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8f8320e387d208369f23791739cd345" id="r_gae8f8320e387d208369f23791739cd345"><td class="memItemLeft" align="right" valign="top">SP_API enum sp_return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae8f8320e387d208369f23791739cd345">sp_nonblocking_write</a> (struct <a class="el" href="structsp__port.html">sp_port</a> *port, const void *buf, size_t count)</td></tr>
<tr class="separator:gae8f8320e387d208369f23791739cd345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b845d6126d49225647800d24e5361c6" id="r_ga5b845d6126d49225647800d24e5361c6"><td class="memItemLeft" align="right" valign="top">SP_API enum sp_return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5b845d6126d49225647800d24e5361c6">sp_input_waiting</a> (struct <a class="el" href="structsp__port.html">sp_port</a> *port)</td></tr>
<tr class="separator:ga5b845d6126d49225647800d24e5361c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9b2955310bb7d38048ce9c250622a52" id="r_gad9b2955310bb7d38048ce9c250622a52"><td class="memItemLeft" align="right" valign="top">SP_API enum sp_return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad9b2955310bb7d38048ce9c250622a52">sp_output_waiting</a> (struct <a class="el" href="structsp__port.html">sp_port</a> *port)</td></tr>
<tr class="separator:gad9b2955310bb7d38048ce9c250622a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd421bc22d467cc07b1d9f286bc83d09" id="r_gacd421bc22d467cc07b1d9f286bc83d09"><td class="memItemLeft" align="right" valign="top">SP_API enum sp_return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacd421bc22d467cc07b1d9f286bc83d09">sp_flush</a> (struct <a class="el" href="structsp__port.html">sp_port</a> *port, enum sp_buffer buffers)</td></tr>
<tr class="separator:gacd421bc22d467cc07b1d9f286bc83d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363f19c17e7db0be010aae1fff7823e5" id="r_ga363f19c17e7db0be010aae1fff7823e5"><td class="memItemLeft" align="right" valign="top">SP_API enum sp_return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga363f19c17e7db0be010aae1fff7823e5">sp_drain</a> (struct <a class="el" href="structsp__port.html">sp_port</a> *port)</td></tr>
<tr class="separator:ga363f19c17e7db0be010aae1fff7823e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Reading, writing, and flushing data.</p>
<p>See <a class="el" href="send_receive_8c-example.html">send_receive.c</a> for an example of sending and receiving data. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaac2cfdd8e8d7b927220196d9f65743fe" name="gaac2cfdd8e8d7b927220196d9f65743fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac2cfdd8e8d7b927220196d9f65743fe">&#9670;&#160;</a></span>sp_blocking_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SP_API enum sp_return sp_blocking_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsp__port.html">sp_port</a> *</td>          <td class="paramname"><span class="paramname"><em>port</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes from the specified serial port, blocking until complete.</p>
<dl class="section warning"><dt>Warning</dt><dd>If your program runs on Unix, defines its own signal handlers, and needs to abort blocking reads when these are called, then you should not use this function. It repeats system calls that return with EINTR. To be able to abort a read from a signal handler, you should implement your own blocking read using <a class="el" href="#gab00baf6fc9d695814bd6b1f3489bf8a4">sp_nonblocking_read()</a> together with a blocking method that makes sense for your program. E.g. you can obtain the file descriptor for an open port using <a class="el" href="group___ports.html#ga61f37e33bc469f1307e35c4c5269b62f">sp_get_port_handle()</a> and use this to call select() or pselect(), with appropriate arrangements to return if a signal is received.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Pointer to a port structure. Must not be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer in which to store the bytes read. Must not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Requested number of bytes to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Timeout in milliseconds, or zero to wait indefinitely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read on success, or a negative error code. If the number of bytes returned is less than that requested, the timeout was reached before the requested number of bytes was available. If timeout is zero, the function will always return either the requested number of bytes or a negative error code.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.1.0 </dd></dl>

</div>
</div>
<a id="gaddc42d25c8bcfb5a3eae54fd0af4144e" name="gaddc42d25c8bcfb5a3eae54fd0af4144e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddc42d25c8bcfb5a3eae54fd0af4144e">&#9670;&#160;</a></span>sp_blocking_read_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SP_API enum sp_return sp_blocking_read_next </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsp__port.html">sp_port</a> *</td>          <td class="paramname"><span class="paramname"><em>port</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes from the specified serial port, returning as soon as any data is available.</p>
<dl class="section warning"><dt>Warning</dt><dd>If your program runs on Unix, defines its own signal handlers, and needs to abort blocking reads when these are called, then you should not use this function. It repeats system calls that return with EINTR. To be able to abort a read from a signal handler, you should implement your own blocking read using <a class="el" href="#gab00baf6fc9d695814bd6b1f3489bf8a4">sp_nonblocking_read()</a> together with a blocking method that makes sense for your program. E.g. you can obtain the file descriptor for an open port using <a class="el" href="group___ports.html#ga61f37e33bc469f1307e35c4c5269b62f">sp_get_port_handle()</a> and use this to call select() or pselect(), with appropriate arrangements to return if a signal is received.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Pointer to a port structure. Must not be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer in which to store the bytes read. Must not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of bytes to read. Must not be zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Timeout in milliseconds, or zero to wait indefinitely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read on success, or a negative error code. If the result is zero, the timeout was reached before any bytes were available. If timeout_ms is zero, the function will always return either at least one byte, or a negative error code.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.1.1 </dd></dl>

</div>
</div>
<a id="ga1457d61301828d8cc18b6f93dca06406" name="ga1457d61301828d8cc18b6f93dca06406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1457d61301828d8cc18b6f93dca06406">&#9670;&#160;</a></span>sp_blocking_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SP_API enum sp_return sp_blocking_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsp__port.html">sp_port</a> *</td>          <td class="paramname"><span class="paramname"><em>port</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write bytes to the specified serial port, blocking until complete.</p>
<p>Note that this function only ensures that the accepted bytes have been written to the OS; they may be held in driver or hardware buffers and not yet physically transmitted. To check whether all written bytes have actually been transmitted, use the <a class="el" href="#gad9b2955310bb7d38048ce9c250622a52">sp_output_waiting()</a> function. To wait until all written bytes have actually been transmitted, use the <a class="el" href="#ga363f19c17e7db0be010aae1fff7823e5">sp_drain()</a> function.</p>
<dl class="section warning"><dt>Warning</dt><dd>If your program runs on Unix, defines its own signal handlers, and needs to abort blocking writes when these are called, then you should not use this function. It repeats system calls that return with EINTR. To be able to abort a write from a signal handler, you should implement your own blocking write using <a class="el" href="#gae8f8320e387d208369f23791739cd345">sp_nonblocking_write()</a> together with a blocking method that makes sense for your program. E.g. you can obtain the file descriptor for an open port using <a class="el" href="group___ports.html#ga61f37e33bc469f1307e35c4c5269b62f">sp_get_port_handle()</a> and use this to call select() or pselect(), with appropriate arrangements to return if a signal is received.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Pointer to a port structure. Must not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Buffer containing the bytes to write. Must not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Requested number of bytes to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Timeout in milliseconds, or zero to wait indefinitely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written on success, or a negative error code. If the number of bytes returned is less than that requested, the timeout was reached before the requested number of bytes was written. If timeout is zero, the function will always return either the requested number of bytes or a negative error code. In the event of an error there is no way to determine how many bytes were sent before the error occurred.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.1.0 </dd></dl>

</div>
</div>
<a id="ga363f19c17e7db0be010aae1fff7823e5" name="ga363f19c17e7db0be010aae1fff7823e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga363f19c17e7db0be010aae1fff7823e5">&#9670;&#160;</a></span>sp_drain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SP_API enum sp_return sp_drain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsp__port.html">sp_port</a> *</td>          <td class="paramname"><span class="paramname"><em>port</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for buffered data to be transmitted.</p>
<dl class="section warning"><dt>Warning</dt><dd>If your program runs on Unix, defines its own signal handlers, and needs to abort draining the output buffer when when these are called, then you should not use this function. It repeats system calls that return with EINTR. To be able to abort a drain from a signal handler, you would need to implement your own blocking drain by polling the result of <a class="el" href="#gad9b2955310bb7d38048ce9c250622a52">sp_output_waiting()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Pointer to a port structure. Must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SP_OK upon success, a negative error code otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.1.0 </dd></dl>

</div>
</div>
<a id="gacd421bc22d467cc07b1d9f286bc83d09" name="gacd421bc22d467cc07b1d9f286bc83d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd421bc22d467cc07b1d9f286bc83d09">&#9670;&#160;</a></span>sp_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SP_API enum sp_return sp_flush </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsp__port.html">sp_port</a> *</td>          <td class="paramname"><span class="paramname"><em>port</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum sp_buffer</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush serial port buffers. Data in the selected buffer(s) is discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Pointer to a port structure. Must not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>Which buffer(s) to flush.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SP_OK upon success, a negative error code otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.1.0 </dd></dl>

</div>
</div>
<a id="ga5b845d6126d49225647800d24e5361c6" name="ga5b845d6126d49225647800d24e5361c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b845d6126d49225647800d24e5361c6">&#9670;&#160;</a></span>sp_input_waiting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SP_API enum sp_return sp_input_waiting </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsp__port.html">sp_port</a> *</td>          <td class="paramname"><span class="paramname"><em>port</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the number of bytes waiting in the input buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Pointer to a port structure. Must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes waiting on success, a negative error code otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.1.0 </dd></dl>

</div>
</div>
<a id="gab00baf6fc9d695814bd6b1f3489bf8a4" name="gab00baf6fc9d695814bd6b1f3489bf8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab00baf6fc9d695814bd6b1f3489bf8a4">&#9670;&#160;</a></span>sp_nonblocking_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SP_API enum sp_return sp_nonblocking_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsp__port.html">sp_port</a> *</td>          <td class="paramname"><span class="paramname"><em>port</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes from the specified serial port, without blocking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Pointer to a port structure. Must not be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer in which to store the bytes read. Must not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read on success, or a negative error code. The number of bytes returned may be any number from zero to the maximum that was requested.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.1.0 </dd></dl>

</div>
</div>
<a id="gae8f8320e387d208369f23791739cd345" name="gae8f8320e387d208369f23791739cd345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8f8320e387d208369f23791739cd345">&#9670;&#160;</a></span>sp_nonblocking_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SP_API enum sp_return sp_nonblocking_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsp__port.html">sp_port</a> *</td>          <td class="paramname"><span class="paramname"><em>port</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write bytes to the specified serial port, without blocking.</p>
<p>Note that this function only ensures that the accepted bytes have been written to the OS; they may be held in driver or hardware buffers and not yet physically transmitted. To check whether all written bytes have actually been transmitted, use the <a class="el" href="#gad9b2955310bb7d38048ce9c250622a52">sp_output_waiting()</a> function. To wait until all written bytes have actually been transmitted, use the <a class="el" href="#ga363f19c17e7db0be010aae1fff7823e5">sp_drain()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Pointer to a port structure. Must not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Buffer containing the bytes to write. Must not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of bytes to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written on success, or a negative error code. The number of bytes returned may be any number from zero to the maximum that was requested.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.1.0 </dd></dl>

</div>
</div>
<a id="gad9b2955310bb7d38048ce9c250622a52" name="gad9b2955310bb7d38048ce9c250622a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9b2955310bb7d38048ce9c250622a52">&#9670;&#160;</a></span>sp_output_waiting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SP_API enum sp_return sp_output_waiting </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsp__port.html">sp_port</a> *</td>          <td class="paramname"><span class="paramname"><em>port</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the number of bytes waiting in the output buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Pointer to a port structure. Must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes waiting on success, a negative error code otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.1.0 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
