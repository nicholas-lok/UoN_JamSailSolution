\doxysection{Data handling}
\hypertarget{group___data}{}\label{group___data}\index{Data handling@{Data handling}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
SP\+\_\+\+API enum sp\+\_\+return \mbox{\hyperlink{group___data_gaac2cfdd8e8d7b927220196d9f65743fe}{sp\+\_\+blocking\+\_\+read}} (struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}port, void \texorpdfstring{$\ast$}{*}buf, size\+\_\+t count, unsigned int timeout\+\_\+ms)
\item 
SP\+\_\+\+API enum sp\+\_\+return \mbox{\hyperlink{group___data_gaddc42d25c8bcfb5a3eae54fd0af4144e}{sp\+\_\+blocking\+\_\+read\+\_\+next}} (struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}port, void \texorpdfstring{$\ast$}{*}buf, size\+\_\+t count, unsigned int timeout\+\_\+ms)
\item 
SP\+\_\+\+API enum sp\+\_\+return \mbox{\hyperlink{group___data_gab00baf6fc9d695814bd6b1f3489bf8a4}{sp\+\_\+nonblocking\+\_\+read}} (struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}port, void \texorpdfstring{$\ast$}{*}buf, size\+\_\+t count)
\item 
SP\+\_\+\+API enum sp\+\_\+return \mbox{\hyperlink{group___data_ga1457d61301828d8cc18b6f93dca06406}{sp\+\_\+blocking\+\_\+write}} (struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}port, const void \texorpdfstring{$\ast$}{*}buf, size\+\_\+t count, unsigned int timeout\+\_\+ms)
\item 
SP\+\_\+\+API enum sp\+\_\+return \mbox{\hyperlink{group___data_gae8f8320e387d208369f23791739cd345}{sp\+\_\+nonblocking\+\_\+write}} (struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}port, const void \texorpdfstring{$\ast$}{*}buf, size\+\_\+t count)
\item 
SP\+\_\+\+API enum sp\+\_\+return \mbox{\hyperlink{group___data_ga5b845d6126d49225647800d24e5361c6}{sp\+\_\+input\+\_\+waiting}} (struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}port)
\item 
SP\+\_\+\+API enum sp\+\_\+return \mbox{\hyperlink{group___data_gad9b2955310bb7d38048ce9c250622a52}{sp\+\_\+output\+\_\+waiting}} (struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}port)
\item 
SP\+\_\+\+API enum sp\+\_\+return \mbox{\hyperlink{group___data_gacd421bc22d467cc07b1d9f286bc83d09}{sp\+\_\+flush}} (struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}port, enum sp\+\_\+buffer buffers)
\item 
SP\+\_\+\+API enum sp\+\_\+return \mbox{\hyperlink{group___data_ga363f19c17e7db0be010aae1fff7823e5}{sp\+\_\+drain}} (struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}port)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Reading, writing, and flushing data.

See \doxylink{send_receive_8c-example}{send\+\_\+receive.\+c} for an example of sending and receiving data. 

\doxysubsection{Function Documentation}
\Hypertarget{group___data_gaac2cfdd8e8d7b927220196d9f65743fe}\label{group___data_gaac2cfdd8e8d7b927220196d9f65743fe} 
\index{Data handling@{Data handling}!sp\_blocking\_read@{sp\_blocking\_read}}
\index{sp\_blocking\_read@{sp\_blocking\_read}!Data handling@{Data handling}}
\doxysubsubsection{\texorpdfstring{sp\_blocking\_read()}{sp\_blocking\_read()}}
{\footnotesize\ttfamily SP\+\_\+\+API enum sp\+\_\+return sp\+\_\+blocking\+\_\+read (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}}]{port,  }\item[{void \texorpdfstring{$\ast$}{*}}]{buf,  }\item[{size\+\_\+t}]{count,  }\item[{unsigned int}]{timeout\+\_\+ms }\end{DoxyParamCaption})}

Read bytes from the specified serial port, blocking until complete.

\begin{DoxyWarning}{Warning}
If your program runs on Unix, defines its own signal handlers, and needs to abort blocking reads when these are called, then you should not use this function. It repeats system calls that return with EINTR. To be able to abort a read from a signal handler, you should implement your own blocking read using \doxylink{group___data_gab00baf6fc9d695814bd6b1f3489bf8a4}{sp\+\_\+nonblocking\+\_\+read()} together with a blocking method that makes sense for your program. E.\+g. you can obtain the file descriptor for an open port using \doxylink{group___ports_ga61f37e33bc469f1307e35c4c5269b62f}{sp\+\_\+get\+\_\+port\+\_\+handle()} and use this to call select() or pselect(), with appropriate arrangements to return if a signal is received.
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em port} & Pointer to a port structure. Must not be NULL. \\
\hline
\mbox{\texttt{ out}}  & {\em buf} & Buffer in which to store the bytes read. Must not be NULL. \\
\hline
\mbox{\texttt{ in}}  & {\em count} & Requested number of bytes to read. \\
\hline
\mbox{\texttt{ in}}  & {\em timeout\+\_\+ms} & Timeout in milliseconds, or zero to wait indefinitely.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes read on success, or a negative error code. If the number of bytes returned is less than that requested, the timeout was reached before the requested number of bytes was available. If timeout is zero, the function will always return either the requested number of bytes or a negative error code.
\end{DoxyReturn}
\begin{DoxySince}{Since}
0.\+1.\+0 
\end{DoxySince}
\Hypertarget{group___data_gaddc42d25c8bcfb5a3eae54fd0af4144e}\label{group___data_gaddc42d25c8bcfb5a3eae54fd0af4144e} 
\index{Data handling@{Data handling}!sp\_blocking\_read\_next@{sp\_blocking\_read\_next}}
\index{sp\_blocking\_read\_next@{sp\_blocking\_read\_next}!Data handling@{Data handling}}
\doxysubsubsection{\texorpdfstring{sp\_blocking\_read\_next()}{sp\_blocking\_read\_next()}}
{\footnotesize\ttfamily SP\+\_\+\+API enum sp\+\_\+return sp\+\_\+blocking\+\_\+read\+\_\+next (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}}]{port,  }\item[{void \texorpdfstring{$\ast$}{*}}]{buf,  }\item[{size\+\_\+t}]{count,  }\item[{unsigned int}]{timeout\+\_\+ms }\end{DoxyParamCaption})}

Read bytes from the specified serial port, returning as soon as any data is available.

\begin{DoxyWarning}{Warning}
If your program runs on Unix, defines its own signal handlers, and needs to abort blocking reads when these are called, then you should not use this function. It repeats system calls that return with EINTR. To be able to abort a read from a signal handler, you should implement your own blocking read using \doxylink{group___data_gab00baf6fc9d695814bd6b1f3489bf8a4}{sp\+\_\+nonblocking\+\_\+read()} together with a blocking method that makes sense for your program. E.\+g. you can obtain the file descriptor for an open port using \doxylink{group___ports_ga61f37e33bc469f1307e35c4c5269b62f}{sp\+\_\+get\+\_\+port\+\_\+handle()} and use this to call select() or pselect(), with appropriate arrangements to return if a signal is received.
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em port} & Pointer to a port structure. Must not be NULL. \\
\hline
\mbox{\texttt{ out}}  & {\em buf} & Buffer in which to store the bytes read. Must not be NULL. \\
\hline
\mbox{\texttt{ in}}  & {\em count} & Maximum number of bytes to read. Must not be zero. \\
\hline
\mbox{\texttt{ in}}  & {\em timeout\+\_\+ms} & Timeout in milliseconds, or zero to wait indefinitely.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes read on success, or a negative error code. If the result is zero, the timeout was reached before any bytes were available. If timeout\+\_\+ms is zero, the function will always return either at least one byte, or a negative error code.
\end{DoxyReturn}
\begin{DoxySince}{Since}
0.\+1.\+1 
\end{DoxySince}
\Hypertarget{group___data_ga1457d61301828d8cc18b6f93dca06406}\label{group___data_ga1457d61301828d8cc18b6f93dca06406} 
\index{Data handling@{Data handling}!sp\_blocking\_write@{sp\_blocking\_write}}
\index{sp\_blocking\_write@{sp\_blocking\_write}!Data handling@{Data handling}}
\doxysubsubsection{\texorpdfstring{sp\_blocking\_write()}{sp\_blocking\_write()}}
{\footnotesize\ttfamily SP\+\_\+\+API enum sp\+\_\+return sp\+\_\+blocking\+\_\+write (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}}]{port,  }\item[{const void \texorpdfstring{$\ast$}{*}}]{buf,  }\item[{size\+\_\+t}]{count,  }\item[{unsigned int}]{timeout\+\_\+ms }\end{DoxyParamCaption})}

Write bytes to the specified serial port, blocking until complete.

Note that this function only ensures that the accepted bytes have been written to the OS; they may be held in driver or hardware buffers and not yet physically transmitted. To check whether all written bytes have actually been transmitted, use the \doxylink{group___data_gad9b2955310bb7d38048ce9c250622a52}{sp\+\_\+output\+\_\+waiting()} function. To wait until all written bytes have actually been transmitted, use the \doxylink{group___data_ga363f19c17e7db0be010aae1fff7823e5}{sp\+\_\+drain()} function.

\begin{DoxyWarning}{Warning}
If your program runs on Unix, defines its own signal handlers, and needs to abort blocking writes when these are called, then you should not use this function. It repeats system calls that return with EINTR. To be able to abort a write from a signal handler, you should implement your own blocking write using \doxylink{group___data_gae8f8320e387d208369f23791739cd345}{sp\+\_\+nonblocking\+\_\+write()} together with a blocking method that makes sense for your program. E.\+g. you can obtain the file descriptor for an open port using \doxylink{group___ports_ga61f37e33bc469f1307e35c4c5269b62f}{sp\+\_\+get\+\_\+port\+\_\+handle()} and use this to call select() or pselect(), with appropriate arrangements to return if a signal is received.
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em port} & Pointer to a port structure. Must not be NULL. \\
\hline
\mbox{\texttt{ in}}  & {\em buf} & Buffer containing the bytes to write. Must not be NULL. \\
\hline
\mbox{\texttt{ in}}  & {\em count} & Requested number of bytes to write. \\
\hline
\mbox{\texttt{ in}}  & {\em timeout\+\_\+ms} & Timeout in milliseconds, or zero to wait indefinitely.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written on success, or a negative error code. If the number of bytes returned is less than that requested, the timeout was reached before the requested number of bytes was written. If timeout is zero, the function will always return either the requested number of bytes or a negative error code. In the event of an error there is no way to determine how many bytes were sent before the error occurred.
\end{DoxyReturn}
\begin{DoxySince}{Since}
0.\+1.\+0 
\end{DoxySince}
\Hypertarget{group___data_ga363f19c17e7db0be010aae1fff7823e5}\label{group___data_ga363f19c17e7db0be010aae1fff7823e5} 
\index{Data handling@{Data handling}!sp\_drain@{sp\_drain}}
\index{sp\_drain@{sp\_drain}!Data handling@{Data handling}}
\doxysubsubsection{\texorpdfstring{sp\_drain()}{sp\_drain()}}
{\footnotesize\ttfamily SP\+\_\+\+API enum sp\+\_\+return sp\+\_\+drain (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}}]{port }\end{DoxyParamCaption})}

Wait for buffered data to be transmitted.

\begin{DoxyWarning}{Warning}
If your program runs on Unix, defines its own signal handlers, and needs to abort draining the output buffer when when these are called, then you should not use this function. It repeats system calls that return with EINTR. To be able to abort a drain from a signal handler, you would need to implement your own blocking drain by polling the result of \doxylink{group___data_gad9b2955310bb7d38048ce9c250622a52}{sp\+\_\+output\+\_\+waiting()}.
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em port} & Pointer to a port structure. Must not be NULL.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
SP\+\_\+\+OK upon success, a negative error code otherwise.
\end{DoxyReturn}
\begin{DoxySince}{Since}
0.\+1.\+0 
\end{DoxySince}
\Hypertarget{group___data_gacd421bc22d467cc07b1d9f286bc83d09}\label{group___data_gacd421bc22d467cc07b1d9f286bc83d09} 
\index{Data handling@{Data handling}!sp\_flush@{sp\_flush}}
\index{sp\_flush@{sp\_flush}!Data handling@{Data handling}}
\doxysubsubsection{\texorpdfstring{sp\_flush()}{sp\_flush()}}
{\footnotesize\ttfamily SP\+\_\+\+API enum sp\+\_\+return sp\+\_\+flush (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}}]{port,  }\item[{enum sp\+\_\+buffer}]{buffers }\end{DoxyParamCaption})}

Flush serial port buffers. Data in the selected buffer(s) is discarded.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em port} & Pointer to a port structure. Must not be NULL. \\
\hline
\mbox{\texttt{ in}}  & {\em buffers} & Which buffer(s) to flush.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
SP\+\_\+\+OK upon success, a negative error code otherwise.
\end{DoxyReturn}
\begin{DoxySince}{Since}
0.\+1.\+0 
\end{DoxySince}
\Hypertarget{group___data_ga5b845d6126d49225647800d24e5361c6}\label{group___data_ga5b845d6126d49225647800d24e5361c6} 
\index{Data handling@{Data handling}!sp\_input\_waiting@{sp\_input\_waiting}}
\index{sp\_input\_waiting@{sp\_input\_waiting}!Data handling@{Data handling}}
\doxysubsubsection{\texorpdfstring{sp\_input\_waiting()}{sp\_input\_waiting()}}
{\footnotesize\ttfamily SP\+\_\+\+API enum sp\+\_\+return sp\+\_\+input\+\_\+waiting (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}}]{port }\end{DoxyParamCaption})}

Gets the number of bytes waiting in the input buffer.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em port} & Pointer to a port structure. Must not be NULL.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes waiting on success, a negative error code otherwise.
\end{DoxyReturn}
\begin{DoxySince}{Since}
0.\+1.\+0 
\end{DoxySince}
\Hypertarget{group___data_gab00baf6fc9d695814bd6b1f3489bf8a4}\label{group___data_gab00baf6fc9d695814bd6b1f3489bf8a4} 
\index{Data handling@{Data handling}!sp\_nonblocking\_read@{sp\_nonblocking\_read}}
\index{sp\_nonblocking\_read@{sp\_nonblocking\_read}!Data handling@{Data handling}}
\doxysubsubsection{\texorpdfstring{sp\_nonblocking\_read()}{sp\_nonblocking\_read()}}
{\footnotesize\ttfamily SP\+\_\+\+API enum sp\+\_\+return sp\+\_\+nonblocking\+\_\+read (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}}]{port,  }\item[{void \texorpdfstring{$\ast$}{*}}]{buf,  }\item[{size\+\_\+t}]{count }\end{DoxyParamCaption})}

Read bytes from the specified serial port, without blocking.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em port} & Pointer to a port structure. Must not be NULL. \\
\hline
\mbox{\texttt{ out}}  & {\em buf} & Buffer in which to store the bytes read. Must not be NULL. \\
\hline
\mbox{\texttt{ in}}  & {\em count} & Maximum number of bytes to read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes read on success, or a negative error code. The number of bytes returned may be any number from zero to the maximum that was requested.
\end{DoxyReturn}
\begin{DoxySince}{Since}
0.\+1.\+0 
\end{DoxySince}
\Hypertarget{group___data_gae8f8320e387d208369f23791739cd345}\label{group___data_gae8f8320e387d208369f23791739cd345} 
\index{Data handling@{Data handling}!sp\_nonblocking\_write@{sp\_nonblocking\_write}}
\index{sp\_nonblocking\_write@{sp\_nonblocking\_write}!Data handling@{Data handling}}
\doxysubsubsection{\texorpdfstring{sp\_nonblocking\_write()}{sp\_nonblocking\_write()}}
{\footnotesize\ttfamily SP\+\_\+\+API enum sp\+\_\+return sp\+\_\+nonblocking\+\_\+write (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}}]{port,  }\item[{const void \texorpdfstring{$\ast$}{*}}]{buf,  }\item[{size\+\_\+t}]{count }\end{DoxyParamCaption})}

Write bytes to the specified serial port, without blocking.

Note that this function only ensures that the accepted bytes have been written to the OS; they may be held in driver or hardware buffers and not yet physically transmitted. To check whether all written bytes have actually been transmitted, use the \doxylink{group___data_gad9b2955310bb7d38048ce9c250622a52}{sp\+\_\+output\+\_\+waiting()} function. To wait until all written bytes have actually been transmitted, use the \doxylink{group___data_ga363f19c17e7db0be010aae1fff7823e5}{sp\+\_\+drain()} function.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em port} & Pointer to a port structure. Must not be NULL. \\
\hline
\mbox{\texttt{ in}}  & {\em buf} & Buffer containing the bytes to write. Must not be NULL. \\
\hline
\mbox{\texttt{ in}}  & {\em count} & Maximum number of bytes to write.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written on success, or a negative error code. The number of bytes returned may be any number from zero to the maximum that was requested.
\end{DoxyReturn}
\begin{DoxySince}{Since}
0.\+1.\+0 
\end{DoxySince}
\Hypertarget{group___data_gad9b2955310bb7d38048ce9c250622a52}\label{group___data_gad9b2955310bb7d38048ce9c250622a52} 
\index{Data handling@{Data handling}!sp\_output\_waiting@{sp\_output\_waiting}}
\index{sp\_output\_waiting@{sp\_output\_waiting}!Data handling@{Data handling}}
\doxysubsubsection{\texorpdfstring{sp\_output\_waiting()}{sp\_output\_waiting()}}
{\footnotesize\ttfamily SP\+\_\+\+API enum sp\+\_\+return sp\+\_\+output\+\_\+waiting (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsp__port}{sp\+\_\+port}} \texorpdfstring{$\ast$}{*}}]{port }\end{DoxyParamCaption})}

Gets the number of bytes waiting in the output buffer.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em port} & Pointer to a port structure. Must not be NULL.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes waiting on success, a negative error code otherwise.
\end{DoxyReturn}
\begin{DoxySince}{Since}
0.\+1.\+0 
\end{DoxySince}
