\chapter{libserialport API}
\hypertarget{index}{}\label{index}\index{libserialport API@{libserialport API}}
\hypertarget{index_autotoc_md0}{}\doxysection{\texorpdfstring{Introduction}{Introduction}}\label{index_autotoc_md0}
libserialport is a minimal library written in C that is intended to take care of the OS-\/specific details when writing software that uses serial ports.

By writing your serial code to use libserialport, you enable it to work transparently on any platform supported by the library.

libserialport is an open source project released under the LGPL3+ license.

The library is maintained by the \href{http://sigrok.org/}{\texttt{ sigrok}} project. See the \href{http://sigrok.org/wiki/Libserialport}{\texttt{ libserialport homepage}} for the latest information.

Source code is maintained in git at \href{http://sigrok.org/gitweb/?p=libserialport.git}{\texttt{ git\+://sigrok.org/libserialport}}.

Bugs are tracked at \href{http://sigrok.org/bugzilla/}{\texttt{ http\+://sigrok.\+org/bugzilla/}}.

The library was conceived and designed by Martin Ling, is maintained by Uwe Hermann, and has received contributions from several other developers. See the git history for full credits.\hypertarget{index_autotoc_md1}{}\doxysection{\texorpdfstring{API information}{API information}}\label{index_autotoc_md1}
The API has been designed from scratch. It does not exactly resemble the serial API of any particular operating system. Instead it aims to provide a set of functions that can reliably be implemented across all operating systems. These form a sufficient basis for higher level behaviour to be implemented in a platform independent manner.

If you are porting code written for a particular OS, you may find you need to restructure things somewhat, or do without some specialised features. For particular notes on porting existing code, see \doxylink{index_Porting}{Porting}.\hypertarget{index_autotoc_md2}{}\doxysubsection{\texorpdfstring{Examples}{Examples}}\label{index_autotoc_md2}
Some simple example programs using libserialport are included in the {\ttfamily examples} directory in the source package\+:


\begin{DoxyItemize}
\item \doxylink{list_ports_8c-example}{list\+\_\+ports.\+c} -\/ Getting a list of ports present on the system.
\item \doxylink{port_info_8c-example}{port\+\_\+info.\+c} -\/ Getting information on a particular serial port.
\item \doxylink{port_config_8c-example}{port\+\_\+config.\+c} -\/ Accessing configuration settings of a port.
\item \doxylink{send_receive_8c-example}{send\+\_\+receive.\+c} -\/ Sending and receiving data.
\item \doxylink{await_events_8c-example}{await\+\_\+events.\+c} -\/ Awaiting events on multiple ports.
\item \doxylink{handle_errors_8c-example}{handle\+\_\+errors.\+c} -\/ Handling errors returned from the library.
\end{DoxyItemize}

These examples are linked with the API documentation. Each function in the API reference includes links to where it is used in an example program, and each appearance of a function in the examples links to that function\textquotesingle{}s entry in the API reference.\hypertarget{index_autotoc_md3}{}\doxysubsection{\texorpdfstring{Headers}{Headers}}\label{index_autotoc_md3}
To use libserialport functions in your code, you should include the \doxylink{libserialport_8h_source}{libserialport.\+h} header, i.\+e. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <libserialport.h>}}

\end{DoxyCode}
\hypertarget{index_autotoc_md4}{}\doxysubsection{\texorpdfstring{Namespace}{Namespace}}\label{index_autotoc_md4}
All identifiers defined by the public libserialport headers use the prefix {\ttfamily sp\+\_\+} (for functions and data types) or {\ttfamily SP\+\_\+} (for macros and constants).\hypertarget{index_autotoc_md5}{}\doxysubsection{\texorpdfstring{Functions}{Functions}}\label{index_autotoc_md5}
The functions provided by the library are documented in detail in the following sections\+:


\begin{DoxyItemize}
\item \doxylink{group___enumeration}{Port enumeration} (obtaining a list of serial ports on the system)
\item \doxylink{group___ports}{Port handling} (opening, closing and getting information about ports)
\item \doxylink{group___configuration}{Configuration} (baud rate, parity, etc.)
\item \doxylink{group___signals}{Signals} (modem control lines, breaks, etc.)
\item \doxylink{group___data}{Data handling} (reading and writing data, and buffer management)
\item \doxylink{group___waiting}{Waiting} (waiting for ports to be ready, integrating with event loops)
\item \doxylink{group___errors}{Errors} (getting error and debugging information)
\end{DoxyItemize}\hypertarget{index_autotoc_md6}{}\doxysubsection{\texorpdfstring{Data structures}{Data structures}}\label{index_autotoc_md6}
The library defines three data structures\+:


\begin{DoxyItemize}
\item \doxylink{structsp__port}{sp\+\_\+port}, which represents a serial port. See \doxylink{group___enumeration}{Port enumeration}.
\item \doxylink{structsp__port__config}{sp\+\_\+port\+\_\+config}, which represents a port configuration. See \doxylink{group___configuration}{Configuration}.
\item \doxylink{structsp__event__set}{sp\+\_\+event\+\_\+set}, which represents a set of events. See \doxylink{group___waiting}{Waiting}.
\end{DoxyItemize}

All these structures are allocated and freed by library functions. It is the caller\textquotesingle{}s responsibility to ensure that the correct calls are made to free allocated structures after use.\hypertarget{index_autotoc_md7}{}\doxysubsection{\texorpdfstring{Return codes and error handling}{Return codes and error handling}}\label{index_autotoc_md7}
Most functions have return type sp\+\_\+return and can return only four possible error values\+:


\begin{DoxyItemize}
\item SP\+\_\+\+ERR\+\_\+\+ARG means that a function was called with invalid arguments. This implies a bug in the caller. The arguments passed would be invalid regardless of the underlying OS or serial device involved.
\item SP\+\_\+\+ERR\+\_\+\+FAIL means that the OS reported a failure. The error code or message provided by the OS can be obtained by calling \doxylink{group___errors_ga5495d846afd494c4722e87788d3c0e3e}{sp\+\_\+last\+\_\+error\+\_\+code()} or \doxylink{group___errors_gaba8ee67046dcb38e14fb58a840573f58}{sp\+\_\+last\+\_\+error\+\_\+message()}.
\item SP\+\_\+\+ERR\+\_\+\+SUPP indicates that there is no support for the requested operation in the current OS, driver or device. No error message is available from the OS in this case. There is either no way to request the operation in the first place, or libserialport does not know how to do so in the current version.
\item SP\+\_\+\+ERR\+\_\+\+MEM indicates that a memory allocation failed.
\end{DoxyItemize}

All of these error values are negative.

Calls that succeed return SP\+\_\+\+OK, which is equal to zero. Some functions declared sp\+\_\+return can also return a positive value for a successful numeric result, e.\+g. \doxylink{group___data_gaac2cfdd8e8d7b927220196d9f65743fe}{sp\+\_\+blocking\+\_\+read()} or \doxylink{group___data_ga1457d61301828d8cc18b6f93dca06406}{sp\+\_\+blocking\+\_\+write()}.

An error message is only available via \doxylink{group___errors_gaba8ee67046dcb38e14fb58a840573f58}{sp\+\_\+last\+\_\+error\+\_\+message()} in the case where SP\+\_\+\+ERR\+\_\+\+FAIL was returned by the previous function call. The error message returned is that provided by the OS, using the current language settings. It is an error to call \doxylink{group___errors_ga5495d846afd494c4722e87788d3c0e3e}{sp\+\_\+last\+\_\+error\+\_\+code()} or \doxylink{group___errors_gaba8ee67046dcb38e14fb58a840573f58}{sp\+\_\+last\+\_\+error\+\_\+message()} except after a previous function call returned SP\+\_\+\+ERR\+\_\+\+FAIL. The library does not define its own error codes or messages to accompany other return codes.\hypertarget{index_autotoc_md8}{}\doxysubsection{\texorpdfstring{Thread safety}{Thread safety}}\label{index_autotoc_md8}
Certain combinations of calls can be made concurrently, as follows.


\begin{DoxyItemize}
\item Calls using different ports may always be made concurrently, i.\+e. it is safe for separate threads to handle their own ports.
\item Calls using the same port may be made concurrently when one call is a read operation and one call is a write operation, i.\+e. it is safe to use separate "{}reader"{} and "{}writer"{} threads for the same port. See below for which operations meet these definitions.
\end{DoxyItemize}

Read operations\+:


\begin{DoxyItemize}
\item \doxylink{group___data_gaac2cfdd8e8d7b927220196d9f65743fe}{sp\+\_\+blocking\+\_\+read()}
\item \doxylink{group___data_gaddc42d25c8bcfb5a3eae54fd0af4144e}{sp\+\_\+blocking\+\_\+read\+\_\+next()}
\item \doxylink{group___data_gab00baf6fc9d695814bd6b1f3489bf8a4}{sp\+\_\+nonblocking\+\_\+read()}
\item \doxylink{group___data_ga5b845d6126d49225647800d24e5361c6}{sp\+\_\+input\+\_\+waiting()}
\item \doxylink{group___data_gacd421bc22d467cc07b1d9f286bc83d09}{sp\+\_\+flush()} with SP\+\_\+\+BUF\+\_\+\+INPUT only.
\item sp\+\_\+wait() with SP\+\_\+\+EVENT\+\_\+\+RX\+\_\+\+READY only.
\end{DoxyItemize}

Write operations\+:


\begin{DoxyItemize}
\item \doxylink{group___data_ga1457d61301828d8cc18b6f93dca06406}{sp\+\_\+blocking\+\_\+write()}
\item \doxylink{group___data_gae8f8320e387d208369f23791739cd345}{sp\+\_\+nonblocking\+\_\+write()}
\item \doxylink{group___data_gad9b2955310bb7d38048ce9c250622a52}{sp\+\_\+output\+\_\+waiting()}
\item \doxylink{group___data_ga363f19c17e7db0be010aae1fff7823e5}{sp\+\_\+drain()}
\item \doxylink{group___data_gacd421bc22d467cc07b1d9f286bc83d09}{sp\+\_\+flush()} with SP\+\_\+\+BUF\+\_\+\+OUTPUT only.
\item sp\+\_\+wait() with SP\+\_\+\+EVENT\+\_\+\+TX\+\_\+\+READY only.
\end{DoxyItemize}

If two calls, on the same port, do not fit into one of these categories each, then they may not be made concurrently.\hypertarget{index_autotoc_md9}{}\doxysubsection{\texorpdfstring{Debugging}{Debugging}}\label{index_autotoc_md9}
The library can output extensive tracing and debugging information. The simplest way to use this is to set the environment variable {\ttfamily LIBSERIALPORT\+\_\+\+DEBUG} to any value; messages will then be output to the standard error stream.

This behaviour is implemented by a default debug message handling callback. An alternative callback can be set using \doxylink{group___errors_ga9b1784c92c1e0d6563fdb6128e521c0a}{sp\+\_\+set\+\_\+debug\+\_\+handler()}, in order to e.\+g. redirect the output elsewhere or filter it.

No guarantees are made about the content of the debug output; it is chosen to suit the needs of the developers and may change between releases.

\label{index_Porting}%
\Hypertarget{index_Porting}%
\hypertarget{index_autotoc_md10}{}\doxysubsection{\texorpdfstring{Porting}{Porting}}\label{index_autotoc_md10}
The following guidelines may help when porting existing OS-\/specific code to use libserialport.\hypertarget{index_autotoc_md11}{}\doxysubsubsection{\texorpdfstring{Porting from Unix-\/like systems}{Porting from Unix-\/like systems}}\label{index_autotoc_md11}
There are two main differences to note when porting code written for Unix.

The first is that Unix traditionally provides a wide range of functionality for dealing with serial devices at the OS level; this is exposed through the termios API and dates to the days when serial terminals were common. If your code relies on many of these facilities you will need to adapt it, because libserialport provides only a raw binary channel with no special handling.

The second relates to blocking versus non-\/blocking I/O behaviour. In Unix-\/like systems this is normally specified by setting the {\ttfamily O\+\_\+\+NONBLOCK} flag on the file descriptor, affecting the semantics of subsequent {\ttfamily read()} and {\ttfamily write()} calls.

In libserialport, blocking and nonblocking operations are both available at any time. If your existing code ѕets {\ttfamily O\+\_\+\+NONBLOCK}, you should use \doxylink{group___data_gab00baf6fc9d695814bd6b1f3489bf8a4}{sp\+\_\+nonblocking\+\_\+read()} and \doxylink{group___data_gae8f8320e387d208369f23791739cd345}{sp\+\_\+nonblocking\+\_\+write()} to get the same behaviour as your existing {\ttfamily read()} and {\ttfamily write()} calls. If it does not, you should use \doxylink{group___data_gaac2cfdd8e8d7b927220196d9f65743fe}{sp\+\_\+blocking\+\_\+read()} and \doxylink{group___data_ga1457d61301828d8cc18b6f93dca06406}{sp\+\_\+blocking\+\_\+write()} instead. You may also find \doxylink{group___data_gaddc42d25c8bcfb5a3eae54fd0af4144e}{sp\+\_\+blocking\+\_\+read\+\_\+next()} useful, which reproduces the semantics of a blocking read() with {\ttfamily VTIME=0} and {\ttfamily VMIN=1} set in termios.

Finally, you should take care if your program uses custom signal handlers. The blocking calls provided by libserialport will restart system calls that return with {\ttfamily EINTR}, so you will need to make your own arrangements if you need to interrupt blocking operations when your signal handlers are called. This is not an issue if you only use the default handlers.\hypertarget{index_autotoc_md12}{}\doxysubsubsection{\texorpdfstring{Porting from Windows}{Porting from Windows}}\label{index_autotoc_md12}
The main consideration when porting from Windows is that there is no direct equivalent for overlapped I/O operations.

If your program does not use overlapped I/O, you can simply use \doxylink{group___data_gaac2cfdd8e8d7b927220196d9f65743fe}{sp\+\_\+blocking\+\_\+read()} and \doxylink{group___data_ga1457d61301828d8cc18b6f93dca06406}{sp\+\_\+blocking\+\_\+write()} as direct equivalents for {\ttfamily Read\+File()} and {\ttfamily Write\+File()}. You may also find \doxylink{group___data_gaddc42d25c8bcfb5a3eae54fd0af4144e}{sp\+\_\+blocking\+\_\+read\+\_\+next()} useful, which reproduces the special semantics of {\ttfamily Read\+File()} with {\ttfamily Read\+Interval\+Timeout} and {\ttfamily Read\+Total\+Timeout\+Multiplier} set to {\ttfamily MAXDWORD} and {\ttfamily Read\+Total\+Timeout\+Constant} set to between {\ttfamily 1} and {\ttfamily MAXDWORD-\/1} .

If your program makes use of overlapped I/O to continue work while a serial operation is in progress, then you can achieve the same results using \doxylink{group___data_gab00baf6fc9d695814bd6b1f3489bf8a4}{sp\+\_\+nonblocking\+\_\+read()} and \doxylink{group___data_gae8f8320e387d208369f23791739cd345}{sp\+\_\+nonblocking\+\_\+write()}.

Generally, overlapped I/O is combined with either waiting for completion once there is no more background work to do (using {\ttfamily Wait\+For\+Single\+Object()} or {\ttfamily Wait\+For\+Multiple\+Objects()}), or periodically checking for completion with {\ttfamily Get\+Overlapped\+Result()}. If the aim is to start a new operation for further data once the previous one has completed, you can instead simply call the nonblocking functions again with the next data. If you need to wait for completion, use sp\+\_\+wait() to determine when the port is ready to send or receive further data. 