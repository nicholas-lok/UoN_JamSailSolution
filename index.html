<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>University of Nottingham JamSail Misson: libserialport API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">University of Nottingham JamSail Misson
   </div>
   <div id="projectbrief">CubeSat Solution</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">libserialport API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md13"></a>
Introduction</h1>
<p>libserialport is a minimal library written in C that is intended to take care of the OS-specific details when writing software that uses serial ports.</p>
<p>By writing your serial code to use libserialport, you enable it to work transparently on any platform supported by the library.</p>
<p>libserialport is an open source project released under the LGPL3+ license.</p>
<p>The library is maintained by the <a href="http://sigrok.org/">sigrok</a> project. See the <a href="http://sigrok.org/wiki/Libserialport">libserialport homepage</a> for the latest information.</p>
<p>Source code is maintained in git at <a href="http://sigrok.org/gitweb/?p=libserialport.git">git://sigrok.org/libserialport</a>.</p>
<p>Bugs are tracked at <a href="http://sigrok.org/bugzilla/">http://sigrok.org/bugzilla/</a>.</p>
<p>The library was conceived and designed by Martin Ling, is maintained by Uwe Hermann, and has received contributions from several other developers. See the git history for full credits.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
API information</h1>
<p>The API has been designed from scratch. It does not exactly resemble the serial API of any particular operating system. Instead it aims to provide a set of functions that can reliably be implemented across all operating systems. These form a sufficient basis for higher level behaviour to be implemented in a platform independent manner.</p>
<p>If you are porting code written for a particular OS, you may find you need to restructure things somewhat, or do without some specialised features. For particular notes on porting existing code, see <a class="el" href="index.html#Porting">Porting</a>.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Examples</h2>
<p>Some simple example programs using libserialport are included in the <code>examples</code> directory in the source package:</p>
<ul>
<li><a class="el" href="list_ports_8c-example.html">list_ports.c</a> - Getting a list of ports present on the system.</li>
<li><a class="el" href="port_info_8c-example.html">port_info.c</a> - Getting information on a particular serial port.</li>
<li><a class="el" href="port_config_8c-example.html">port_config.c</a> - Accessing configuration settings of a port.</li>
<li><a class="el" href="send_receive_8c-example.html">send_receive.c</a> - Sending and receiving data.</li>
<li><a class="el" href="await_events_8c-example.html">await_events.c</a> - Awaiting events on multiple ports.</li>
<li><a class="el" href="handle_errors_8c-example.html">handle_errors.c</a> - Handling errors returned from the library.</li>
</ul>
<p>These examples are linked with the API documentation. Each function in the API reference includes links to where it is used in an example program, and each appearance of a function in the examples links to that function's entry in the API reference.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Headers</h2>
<p>To use libserialport functions in your code, you should include the <a class="el" href="libserialport_8h_source.html">libserialport.h</a> header, i.e. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;libserialport.h&gt;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
Namespace</h2>
<p>All identifiers defined by the public libserialport headers use the prefix <code>sp_</code> (for functions and data types) or <code>SP_</code> (for macros and constants).</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Functions</h2>
<p>The functions provided by the library are documented in detail in the following sections:</p>
<ul>
<li><a class="el" href="group__Enumeration.html">Port enumeration</a> (obtaining a list of serial ports on the system)</li>
<li><a class="el" href="group__Ports.html">Port handling</a> (opening, closing and getting information about ports)</li>
<li><a class="el" href="group__Configuration.html">Configuration</a> (baud rate, parity, etc.)</li>
<li><a class="el" href="group__Signals.html">Signals</a> (modem control lines, breaks, etc.)</li>
<li><a class="el" href="group__Data.html">Data handling</a> (reading and writing data, and buffer management)</li>
<li><a class="el" href="group__Waiting.html">Waiting</a> (waiting for ports to be ready, integrating with event loops)</li>
<li><a class="el" href="group__Errors.html">Errors</a> (getting error and debugging information)</li>
</ul>
<h2><a class="anchor" id="autotoc_md19"></a>
Data structures</h2>
<p>The library defines three data structures:</p>
<ul>
<li><a class="el" href="structsp__port.html">sp_port</a>, which represents a serial port. See <a class="el" href="group__Enumeration.html">Port enumeration</a>.</li>
<li><a class="el" href="structsp__port__config.html">sp_port_config</a>, which represents a port configuration. See <a class="el" href="group__Configuration.html">Configuration</a>.</li>
<li><a class="el" href="structsp__event__set.html">sp_event_set</a>, which represents a set of events. See <a class="el" href="group__Waiting.html">Waiting</a>.</li>
</ul>
<p>All these structures are allocated and freed by library functions. It is the caller's responsibility to ensure that the correct calls are made to free allocated structures after use.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Return codes and error handling</h2>
<p>Most functions have return type sp_return and can return only four possible error values:</p>
<ul>
<li>SP_ERR_ARG means that a function was called with invalid arguments. This implies a bug in the caller. The arguments passed would be invalid regardless of the underlying OS or serial device involved.</li>
<li>SP_ERR_FAIL means that the OS reported a failure. The error code or message provided by the OS can be obtained by calling <a class="el" href="group__Errors.html#ga5495d846afd494c4722e87788d3c0e3e">sp_last_error_code()</a> or <a class="el" href="group__Errors.html#ga7d37854fc5f1f854d8aa1bb0d26681a6">sp_last_error_message()</a>.</li>
<li>SP_ERR_SUPP indicates that there is no support for the requested operation in the current OS, driver or device. No error message is available from the OS in this case. There is either no way to request the operation in the first place, or libserialport does not know how to do so in the current version.</li>
<li>SP_ERR_MEM indicates that a memory allocation failed.</li>
</ul>
<p>All of these error values are negative.</p>
<p>Calls that succeed return SP_OK, which is equal to zero. Some functions declared sp_return can also return a positive value for a successful numeric result, e.g. <a class="el" href="group__Data.html#gaac2cfdd8e8d7b927220196d9f65743fe">sp_blocking_read()</a> or <a class="el" href="group__Data.html#ga1457d61301828d8cc18b6f93dca06406">sp_blocking_write()</a>.</p>
<p>An error message is only available via <a class="el" href="group__Errors.html#ga7d37854fc5f1f854d8aa1bb0d26681a6">sp_last_error_message()</a> in the case where SP_ERR_FAIL was returned by the previous function call. The error message returned is that provided by the OS, using the current language settings. It is an error to call <a class="el" href="group__Errors.html#ga5495d846afd494c4722e87788d3c0e3e">sp_last_error_code()</a> or <a class="el" href="group__Errors.html#ga7d37854fc5f1f854d8aa1bb0d26681a6">sp_last_error_message()</a> except after a previous function call returned SP_ERR_FAIL. The library does not define its own error codes or messages to accompany other return codes.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
Thread safety</h2>
<p>Certain combinations of calls can be made concurrently, as follows.</p>
<ul>
<li>Calls using different ports may always be made concurrently, i.e. it is safe for separate threads to handle their own ports.</li>
<li>Calls using the same port may be made concurrently when one call is a read operation and one call is a write operation, i.e. it is safe to use separate "reader" and "writer" threads for the same port. See below for which operations meet these definitions.</li>
</ul>
<p>Read operations:</p>
<ul>
<li><a class="el" href="group__Data.html#gaac2cfdd8e8d7b927220196d9f65743fe">sp_blocking_read()</a></li>
<li><a class="el" href="group__Data.html#gaddc42d25c8bcfb5a3eae54fd0af4144e">sp_blocking_read_next()</a></li>
<li><a class="el" href="group__Data.html#gab00baf6fc9d695814bd6b1f3489bf8a4">sp_nonblocking_read()</a></li>
<li><a class="el" href="group__Data.html#ga5b845d6126d49225647800d24e5361c6">sp_input_waiting()</a></li>
<li><a class="el" href="group__Data.html#gacd421bc22d467cc07b1d9f286bc83d09">sp_flush()</a> with SP_BUF_INPUT only.</li>
<li><a class="el" href="group__Waiting.html#ga79f92a0583e0ef49a34a94aa009bbd26">sp_wait()</a> with SP_EVENT_RX_READY only.</li>
</ul>
<p>Write operations:</p>
<ul>
<li><a class="el" href="group__Data.html#ga1457d61301828d8cc18b6f93dca06406">sp_blocking_write()</a></li>
<li><a class="el" href="group__Data.html#gae8f8320e387d208369f23791739cd345">sp_nonblocking_write()</a></li>
<li><a class="el" href="group__Data.html#gad9b2955310bb7d38048ce9c250622a52">sp_output_waiting()</a></li>
<li><a class="el" href="group__Data.html#ga363f19c17e7db0be010aae1fff7823e5">sp_drain()</a></li>
<li><a class="el" href="group__Data.html#gacd421bc22d467cc07b1d9f286bc83d09">sp_flush()</a> with SP_BUF_OUTPUT only.</li>
<li><a class="el" href="group__Waiting.html#ga79f92a0583e0ef49a34a94aa009bbd26">sp_wait()</a> with SP_EVENT_TX_READY only.</li>
</ul>
<p>If two calls, on the same port, do not fit into one of these categories each, then they may not be made concurrently.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Debugging</h2>
<p>The library can output extensive tracing and debugging information. The simplest way to use this is to set the environment variable <code>LIBSERIALPORT_DEBUG</code> to any value; messages will then be output to the standard error stream.</p>
<p>This behaviour is implemented by a default debug message handling callback. An alternative callback can be set using <a class="el" href="group__Errors.html#ga9b1784c92c1e0d6563fdb6128e521c0a">sp_set_debug_handler()</a>, in order to e.g. redirect the output elsewhere or filter it.</p>
<p>No guarantees are made about the content of the debug output; it is chosen to suit the needs of the developers and may change between releases.</p>
<p><a class="anchor" id="Porting"></a></p>
<h2><a class="anchor" id="autotoc_md23"></a>
Porting</h2>
<p>The following guidelines may help when porting existing OS-specific code to use libserialport.</p>
<h3><a class="anchor" id="autotoc_md24"></a>
Porting from Unix-like systems</h3>
<p>There are two main differences to note when porting code written for Unix.</p>
<p>The first is that Unix traditionally provides a wide range of functionality for dealing with serial devices at the OS level; this is exposed through the termios API and dates to the days when serial terminals were common. If your code relies on many of these facilities you will need to adapt it, because libserialport provides only a raw binary channel with no special handling.</p>
<p>The second relates to blocking versus non-blocking I/O behaviour. In Unix-like systems this is normally specified by setting the <code>O_NONBLOCK</code> flag on the file descriptor, affecting the semantics of subsequent <code>read()</code> and <code>write()</code> calls.</p>
<p>In libserialport, blocking and nonblocking operations are both available at any time. If your existing code Ñ•ets <code>O_NONBLOCK</code>, you should use <a class="el" href="group__Data.html#gab00baf6fc9d695814bd6b1f3489bf8a4">sp_nonblocking_read()</a> and <a class="el" href="group__Data.html#gae8f8320e387d208369f23791739cd345">sp_nonblocking_write()</a> to get the same behaviour as your existing <code>read()</code> and <code>write()</code> calls. If it does not, you should use <a class="el" href="group__Data.html#gaac2cfdd8e8d7b927220196d9f65743fe">sp_blocking_read()</a> and <a class="el" href="group__Data.html#ga1457d61301828d8cc18b6f93dca06406">sp_blocking_write()</a> instead. You may also find <a class="el" href="group__Data.html#gaddc42d25c8bcfb5a3eae54fd0af4144e">sp_blocking_read_next()</a> useful, which reproduces the semantics of a blocking read() with <code>VTIME=0</code> and <code>VMIN=1</code> set in termios.</p>
<p>Finally, you should take care if your program uses custom signal handlers. The blocking calls provided by libserialport will restart system calls that return with <code>EINTR</code>, so you will need to make your own arrangements if you need to interrupt blocking operations when your signal handlers are called. This is not an issue if you only use the default handlers.</p>
<h3><a class="anchor" id="autotoc_md25"></a>
Porting from Windows</h3>
<p>The main consideration when porting from Windows is that there is no direct equivalent for overlapped I/O operations.</p>
<p>If your program does not use overlapped I/O, you can simply use <a class="el" href="group__Data.html#gaac2cfdd8e8d7b927220196d9f65743fe">sp_blocking_read()</a> and <a class="el" href="group__Data.html#ga1457d61301828d8cc18b6f93dca06406">sp_blocking_write()</a> as direct equivalents for <code>ReadFile()</code> and <code>WriteFile()</code>. You may also find <a class="el" href="group__Data.html#gaddc42d25c8bcfb5a3eae54fd0af4144e">sp_blocking_read_next()</a> useful, which reproduces the special semantics of <code>ReadFile()</code> with <code>ReadIntervalTimeout</code> and <code>ReadTotalTimeoutMultiplier</code> set to <code>MAXDWORD</code> and <code>ReadTotalTimeoutConstant</code> set to between <code>1</code> and <code>MAXDWORD-1</code> .</p>
<p>If your program makes use of overlapped I/O to continue work while a serial operation is in progress, then you can achieve the same results using <a class="el" href="group__Data.html#gab00baf6fc9d695814bd6b1f3489bf8a4">sp_nonblocking_read()</a> and <a class="el" href="group__Data.html#gae8f8320e387d208369f23791739cd345">sp_nonblocking_write()</a>.</p>
<p>Generally, overlapped I/O is combined with either waiting for completion once there is no more background work to do (using <code>WaitForSingleObject()</code> or <code>WaitForMultipleObjects()</code>), or periodically checking for completion with <code>GetOverlappedResult()</code>. If the aim is to start a new operation for further data once the previous one has completed, you can instead simply call the nonblocking functions again with the next data. If you need to wait for completion, use <a class="el" href="group__Waiting.html#ga79f92a0583e0ef49a34a94aa009bbd26">sp_wait()</a> to determine when the port is ready to send or receive further data. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
